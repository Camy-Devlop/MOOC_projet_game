# lextab.py. This file automatically created by PLY (version 3.11). Don't edit!
_tabversion   = '3.10'
_lextokens    = set(('AND', 'AS', 'CALL', 'COLON', 'COMMENT', 'DEDENT', 'DOCUMENT_START', 'ELIF', 'ELSE', 'EMPTYDICT', 'EMPTYLIST', 'EQ', 'EXPRESSION_START', 'EXTEND', 'FLOAT', 'FLOOR_DIVIDE', 'FOR', 'GE', 'GTLT', 'HYPHEN', 'IDENTIFIER', 'IF', 'IN', 'INCLUDE', 'INDENT', 'INTEGER', 'IS', 'LAMBDA', 'LDBRACE', 'LE', 'LSHIFT', 'MACRO', 'MULTILINE', 'MULTILINE_END', 'NE', 'NEW', 'NEWLINE', 'NOT', 'OR', 'POW', 'PROTOTYPE', 'RDBRACE', 'RSHIFT', 'SEARCH', 'SELECT', 'SET', 'STRING', 'VALUE', 'WS'))
_lexreflags   = 0
_lexliterals  = '+-*/%&|^~<>()[]{}@,:.`=;'
_lexstateinfo = {'INITIAL': 'inclusive', 'VALUE': 'exclusive', 'TEMPLATE': 'exclusive', 'COMMAND': 'exclusive', 'BLOCK': 'exclusive', 'QVALUE': 'exclusive', 'CVALUE': 'exclusive'}
_lexstatere   = {'INITIAL': [('(?P<t_INITIAL_VALUE_TEMPLATE_COMMAND_COMMENT>\\#[^\\n]*)|(?P<t_INITIAL_HYPHEN>-[ \\t]*)|(?P<t_INITIAL_VALUE>([^:\\n ]|:(?!\\s))+)|(?P<t_INITIAL_VALUE_TEMPLATE_COMMAND_WS>\\ +)|(?P<t_ANY_NEWLINE>\\n+)|(?P<t_INITIAL_EXTEND>extend)', [None, ('t_INITIAL_VALUE_TEMPLATE_COMMAND_COMMENT', 'COMMENT'), ('t_INITIAL_HYPHEN', 'HYPHEN'), ('t_INITIAL_VALUE', 'VALUE'), None, ('t_INITIAL_VALUE_TEMPLATE_COMMAND_WS', 'WS'), ('t_ANY_NEWLINE', 'NEWLINE'), (None, 'EXTEND')])], 'VALUE': [('(?P<t_INITIAL_VALUE_TEMPLATE_COMMAND_COMMENT>\\#[^\\n]*)|(?P<t_VALUE_COLON>\\ *:\\ *((?:\n)| ))|(?P<t_VALUE_EMPTYDICT>[ ]*{})|(?P<t_VALUE_EMPTYLIST>\\ *\\[\\])|(?P<t_VALUE_QVALUE_CVALUE_BLOCK_LDBRACE>{{)|(?P<t_VALUE_MULTILINE>(>|\\|[+-]?)[ ]*[\\n]+)|(?P<t_VALUE_QUOTE>\\")|(?P<t_VALUE_WSVALUE>([^:\\{\\n]|{(?!{)|:(?!\\s))+(?=\\n))|(?P<t_VALUE_CVALUE_VALUE>([^:\\{\\n]|{(?!{)|:(?!\\s))+)|(?P<t_INITIAL_VALUE_TEMPLATE_COMMAND_WS>\\ +)|(?P<t_ANY_NEWLINE>\\n+)', [None, ('t_INITIAL_VALUE_TEMPLATE_COMMAND_COMMENT', 'COMMENT'), ('t_VALUE_COLON', 'COLON'), None, ('t_VALUE_EMPTYDICT', 'EMPTYDICT'), ('t_VALUE_EMPTYLIST', 'EMPTYLIST'), ('t_VALUE_QVALUE_CVALUE_BLOCK_LDBRACE', 'LDBRACE'), ('t_VALUE_MULTILINE', 'MULTILINE'), None, ('t_VALUE_QUOTE', 'QUOTE'), ('t_VALUE_WSVALUE', 'WSVALUE'), None, ('t_VALUE_CVALUE_VALUE', 'VALUE'), None, ('t_INITIAL_VALUE_TEMPLATE_COMMAND_WS', 'WS'), ('t_ANY_NEWLINE', 'NEWLINE')])], 'TEMPLATE': [('(?P<t_INITIAL_VALUE_TEMPLATE_COMMAND_COMMENT>\\#[^\\n]*)|(?P<t_TEMPLATE_RDBRACE>}})|(?P<t_COMMAND_TEMPLATE_STRING>\n                         [uU]?[rR]?\n                         (?:              # Single-quote (\') strings\n                         \'\'\'(?:                 # Triple-quoted can contain...\n                         [^\']               | # a non-quote\n                         \\\\\'                | # a backslashed quote\n                         \'{1,2}(?!\')          # one or two quotes\n                         )*\'\'\' |\n                         \'(?:                   # Non-triple quoted can contain...\n                         [^\']                | # a non-quote\n                         \\\\\'                   # a backslashded quote\n                         )*\'(?!\') |                # Double-quote (") strings\n                                       """(?:                 # Triple-quoted can contain...\n                                       [^"]               | # a non-quote\n                                       \\\\"                | # a backslashed single\n                                       "{1,2}(?!")          # one or two quotes\n                                       )*""" |\n                                       "(?:                   # Non-triple quoted can contain...\n                                       [^"]                | # a non-quote\n                                       \\\\"                   # a backslashed quote\n                                       )*"(?!")\n                                       ))|(?P<t_COMMAND_TEMPLATE_INTEGER>\n        (?<![\\w.])               #Start of string or non-alpha non-decimal point\n            0[X][0-9A-F]+L?|     #Hexadecimal\n            0[O][0-7]+L?|        #Octal\n            0[B][01]+L?|         #Binary\n            [1-9]\\d*L?           #Decimal/Long Decimal, will not match 0____\n        (?![\\w.])                #End of string or non-alpha non-decimal point\n        )|(?P<t_COMMAND_TEMPLATE_FLOAT>(\\d+(?:\\.\\d+)?(?:[eE][+-]\\d+)?))|(?P<t_INITIAL_VALUE_TEMPLATE_COMMAND_WS>\\ +)|(?P<t_COMMAND_TEMPLATE_IDENTIFIER>[A-Za-z_][A-Za-z0-9_]*)|(?P<t_ANY_NEWLINE>\\n+)|(?P<t_COMMAND_TEMPLATE_POW>\\*\\*)|(?P<t_COMMAND_TEMPLATE_EQ>==)|(?P<t_COMMAND_TEMPLATE_FLOOR_DIVIDE>//)|(?P<t_COMMAND_TEMPLATE_GE>>=)|(?P<t_COMMAND_TEMPLATE_GTLT><>)|(?P<t_COMMAND_TEMPLATE_LE><=)|(?P<t_COMMAND_TEMPLATE_LSHIFT><<)|(?P<t_COMMAND_TEMPLATE_NE>!=)|(?P<t_COMMAND_TEMPLATE_RSHIFT>>>)', [None, ('t_INITIAL_VALUE_TEMPLATE_COMMAND_COMMENT', 'COMMENT'), ('t_TEMPLATE_RDBRACE', 'RDBRACE'), ('t_COMMAND_TEMPLATE_STRING', 'STRING'), None, None, ('t_COMMAND_TEMPLATE_INTEGER', 'INTEGER'), ('t_COMMAND_TEMPLATE_FLOAT', 'FLOAT'), None, ('t_INITIAL_VALUE_TEMPLATE_COMMAND_WS', 'WS'), ('t_COMMAND_TEMPLATE_IDENTIFIER', 'IDENTIFIER'), ('t_ANY_NEWLINE', 'NEWLINE'), (None, 'POW'), (None, 'EQ'), (None, 'FLOOR_DIVIDE'), (None, 'GE'), (None, 'GTLT'), (None, 'LE'), (None, 'LSHIFT'), (None, 'NE'), (None, 'RSHIFT')])], 'COMMAND': [('(?P<t_COMMAND_CONTINUATION>\\\\\\n)|(?P<t_INITIAL_VALUE_TEMPLATE_COMMAND_COMMENT>\\#[^\\n]*)|(?P<t_COMMAND_TEMPLATE_STRING>\n                         [uU]?[rR]?\n                         (?:              # Single-quote (\') strings\n                         \'\'\'(?:                 # Triple-quoted can contain...\n                         [^\']               | # a non-quote\n                         \\\\\'                | # a backslashed quote\n                         \'{1,2}(?!\')          # one or two quotes\n                         )*\'\'\' |\n                         \'(?:                   # Non-triple quoted can contain...\n                         [^\']                | # a non-quote\n                         \\\\\'                   # a backslashded quote\n                         )*\'(?!\') |                # Double-quote (") strings\n                                       """(?:                 # Triple-quoted can contain...\n                                       [^"]               | # a non-quote\n                                       \\\\"                | # a backslashed single\n                                       "{1,2}(?!")          # one or two quotes\n                                       )*""" |\n                                       "(?:                   # Non-triple quoted can contain...\n                                       [^"]                | # a non-quote\n                                       \\\\"                   # a backslashed quote\n                                       )*"(?!")\n                                       ))|(?P<t_COMMAND_TEMPLATE_INTEGER>\n        (?<![\\w.])               #Start of string or non-alpha non-decimal point\n            0[X][0-9A-F]+L?|     #Hexadecimal\n            0[O][0-7]+L?|        #Octal\n            0[B][01]+L?|         #Binary\n            [1-9]\\d*L?           #Decimal/Long Decimal, will not match 0____\n        (?![\\w.])                #End of string or non-alpha non-decimal point\n        )|(?P<t_COMMAND_TEMPLATE_FLOAT>(\\d+(?:\\.\\d+)?(?:[eE][+-]\\d+)?))|(?P<t_INITIAL_VALUE_TEMPLATE_COMMAND_WS>\\ +)|(?P<t_COMMAND_TEMPLATE_IDENTIFIER>[A-Za-z_][A-Za-z0-9_]*)|(?P<t_ANY_NEWLINE>\\n+)|(?P<t_COMMAND_TEMPLATE_POW>\\*\\*)|(?P<t_COMMAND_TEMPLATE_EQ>==)|(?P<t_COMMAND_TEMPLATE_FLOOR_DIVIDE>//)|(?P<t_COMMAND_TEMPLATE_GE>>=)|(?P<t_COMMAND_TEMPLATE_GTLT><>)|(?P<t_COMMAND_TEMPLATE_LE><=)|(?P<t_COMMAND_TEMPLATE_LSHIFT><<)|(?P<t_COMMAND_TEMPLATE_NE>!=)|(?P<t_COMMAND_TEMPLATE_RSHIFT>>>)', [None, ('t_COMMAND_CONTINUATION', 'CONTINUATION'), ('t_INITIAL_VALUE_TEMPLATE_COMMAND_COMMENT', 'COMMENT'), ('t_COMMAND_TEMPLATE_STRING', 'STRING'), None, None, ('t_COMMAND_TEMPLATE_INTEGER', 'INTEGER'), ('t_COMMAND_TEMPLATE_FLOAT', 'FLOAT'), None, ('t_INITIAL_VALUE_TEMPLATE_COMMAND_WS', 'WS'), ('t_COMMAND_TEMPLATE_IDENTIFIER', 'IDENTIFIER'), ('t_ANY_NEWLINE', 'NEWLINE'), (None, 'POW'), (None, 'EQ'), (None, 'FLOOR_DIVIDE'), (None, 'GE'), (None, 'GTLT'), (None, 'LE'), (None, 'LSHIFT'), (None, 'NE'), (None, 'RSHIFT')])], 'BLOCK': [('(?P<t_VALUE_QVALUE_CVALUE_BLOCK_LDBRACE>{{)|(?P<t_BLOCK_WS>\\ +)|(?P<t_BLOCK_VALUE>[^:\\{\\n]+)|(?P<t_ANY_NEWLINE>\\n+)', [None, ('t_VALUE_QVALUE_CVALUE_BLOCK_LDBRACE', 'LDBRACE'), ('t_BLOCK_WS', 'WS'), ('t_BLOCK_VALUE', 'VALUE'), ('t_ANY_NEWLINE', 'NEWLINE')])], 'QVALUE': [('(?P<t_VALUE_QVALUE_CVALUE_BLOCK_LDBRACE>{{)|(?P<t_QVALUE_QUOTE>\\")|(?P<t_QVALUE_VALUE>([^\\{\\n\\"]|{(?!{))+)|(?P<t_ANY_NEWLINE>\\n+)', [None, ('t_VALUE_QVALUE_CVALUE_BLOCK_LDBRACE', 'LDBRACE'), ('t_QVALUE_QUOTE', 'QUOTE'), ('t_QVALUE_VALUE', 'VALUE'), None, ('t_ANY_NEWLINE', 'NEWLINE')])], 'CVALUE': [('(?P<t_VALUE_QVALUE_CVALUE_BLOCK_LDBRACE>{{)|(?P<t_VALUE_CVALUE_VALUE>([^:\\{\\n]|{(?!{)|:(?!\\s))+)|(?P<t_ANY_NEWLINE>\\n+)', [None, ('t_VALUE_QVALUE_CVALUE_BLOCK_LDBRACE', 'LDBRACE'), ('t_VALUE_CVALUE_VALUE', 'VALUE'), None, ('t_ANY_NEWLINE', 'NEWLINE')])]}
_lexstateignore = {'INITIAL': ''}
_lexstateerrorf = {'INITIAL': 't_ANY_error', 'VALUE': 't_ANY_error', 'TEMPLATE': 't_ANY_error', 'COMMAND': 't_ANY_error', 'BLOCK': 't_ANY_error', 'QVALUE': 't_ANY_error', 'CVALUE': 't_ANY_error'}
_lexstateeoff = {}
